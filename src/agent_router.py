"""Agent 1 (OpenAI) - роутер логики и генератор промптов для DeepSeek."""
import json
import logging
import random
import secrets
from typing import Dict, Any, Optional
from openai import OpenAI

from config import OPENAI_API_KEY

logger = logging.getLogger(__name__)

# Список моралей для разных возрастов
MORALS_BY_AGE = {
    "3-5": [
        "Дружить важнее, чем владеть игрушкой",
        "Делая добро, ты сам становишься счастливее",
        "Делиться — не значит терять",
        "Мама и папа помогают, даже когда запрещают",
        "Добрые слова делают мир мягче",
        "Драться — не способ решать проблемы",
        "Помогать другим — это правильно",
        "Если ошибся, можно попросить прощения",
        "Жадность мешает радоваться",
        "Вежливость открывает сердца",
    ],
    "6-8": [
        "Честность важнее выгоды",
        "Усилие приводит к результату",
        "Не суди других по внешности",
        "Каждый поступок имеет последствия",
        "Настойчивость помогает достигать цели",
        "Ошибки — часть обучения",
        "Хвастовство отталкивает друзей",
        "Быть справедливым важнее чем быть первым",
        "Доброта возвращается",
    ],
    "9-12": [
        "Справедливость важнее личной выгоды",
        "Ответственность — это умение держать слово",
        "Зависть разрушает, труд развивает",
        "Каждый человек ценен, даже если он не похож на тебя",
        "Самоконтроль это сила",
        "Настоящая дружба проверяется поступками",
        "Ошибаться не стыдно, стыдно не учиться",
        "Уважение нужно заслужить делами",
        "Смелость — это делать правильно, даже когда трудно",
    ],
    "13+": [
        "Честность с собой важнее одобрения окружающих",
        "Характер формируется в сложных ситуациях",
        "Популярность не равна уважению",
        "Успех без совести не делает счастливым",
        "Выбор — это всегда отказ от чего-то другого",
        "Сильный человек умеет признавать ошибки",
        "Не каждый конфликт нужно выигрывать",
        "Ценности важнее обстоятельств",
        "Ты отвечаешь не только за свои желания, но и за последствия своих поступков",
    ],
}


class AgentRouter:
    """Agent 1: анализирует сообщения и формирует промпты для DeepSeek."""
    
    def __init__(self):
        self.client = OpenAI(
            api_key=OPENAI_API_KEY,
            base_url="https://api.proxyapi.ru/openai/v1"
        )
    
    def process_message(
        self,
        user_message: str,
        user_profile: Optional[Dict[str, Any]] = None,
        is_add_traits_request: bool = False
    ) -> Dict[str, Any]:
        """
        Обрабатывает сообщение пользователя и возвращает JSON-ответ.
        
        Возвращает:
        {
            "should_update_profile": bool,
            "profile_patch": {
                "child_names": "string_optional",
                "age": "string_optional",
                "traits": "string_optional",
                "last_user_message": "string_optional"
            },
            "deepseek_user_prompt": "string"
        }
        """
        try:
            # Формируем системный промпт для Agent 1
            system_prompt = """Ты — интеллектуальный роутер для бота "Сказочник", который помогает родителям наставлять детей через сказки.

Твоя задача:
1. Анализировать сообщения пользователя
2. Определять, нужно ли обновлять профиль ребенка (имя, возраст, черты характера)
3. Формировать промпт для генерации сказки

ПРАВИЛА:
- Если пользователь корректирует профиль ("ему 6, а не 5", "он не спокойный, а упрямый", "двое детей: Маша и Петя") → should_update_profile=true и заполни profile_patch
- Если запрос просто "напиши сказку про..." или обычный запрос сказки → should_update_profile=false

ОСОБЫЕ ПРАВИЛА ДЛЯ ОБНОВЛЕНИЯ ХАРАКТЕРА (traits):
- Если пользователь хочет УДАЛИТЬ характер полностью ("сотри прошлый характер", "удали характер", "убери все черты") → traits = "" (пустая строка)
- Если пользователь хочет УДАЛИТЬ частично ("убери упрямство", "удали спокойный", "убери жадность") → traits = финальный список черт БЕЗ указанных для удаления
- Если пользователь хочет ЗАМЕНИТЬ ("теперь он вежливый", "замени на вежливый", "вместо упрямого теперь вежливый") → traits = новое значение (заменяет полностью)
- Если пользователь хочет ДОПОЛНИТЬ ("также вежливый", "добавь вежливый", "еще он вежливый") → traits = текущий характер + новые черты
- Если в сообщении есть слова "сотри", "удали", "убери", "замени", "вместо" → это указание на удаление/замену, а не дополнение
- ВАЖНО: Если пользователь просто описывает новые черты характера БЕЗ явных слов удаления/замены (например, "Платон Лидер — умеет вести за собой, Наставник — любит объяснять"), это считается ДОПОЛНЕНИЕМ, а не заменой. Сохраняй текущий характер и добавляй новые черты.
- КРИТИЧЕСКИ ВАЖНО: Если в текущем характере есть имена детей (например, "Платон Лидер — ... Демид Создатель — ..."), при дополнении ОБЯЗАТЕЛЬНО сохраняй структуру с именами. Не смешивай черты разных детей в один список.

- deepseek_user_prompt: на русском языке, не в стихах, 500-800 слов (ОБЯЗАТЕЛЬНО соблюдай эту длину), учитывай профиль ребенка(детей) + запрос пользователя. 
- Не проси писать про возраст детей текстом, но ОБЯЗАТЕЛЬНО проси учитывать возраст при написании сказки: в зависимости от возраста регулируй сложность контекста, литературных выражений и морали.
- Не проси писать черты характера текстом, но ОБЯЗАТЕЛЬНО проси отразить их в поведении и поступках героя.
- НИКОГДА не проси писать мораль текстом в конце или в середине сказки. Мораль должна быть скрытой, понятной только из действий героя.
- НЕ используй мат и контент 18+

ВАЖНО: Возвращай ТОЛЬКО валидный JSON без пояснений и комментариев."""

            # Формируем промпт пользователя
            profile_info = ""
            current_traits = ""
            if user_profile:
                current_traits = user_profile.get('traits', '').strip()
                profile_info = f"""
Профиль ребенка:
- Имя: {user_profile.get('child_names', 'не указано')}
- Возраст: {user_profile.get('age', 'не указан')}
- Текущие черты характера: {current_traits if current_traits else 'не указаны'}
"""
            
            traits_instructions = ""
            if current_traits:
                # Проверяем, есть ли в traits имена детей (начинается с имени или содержит структуру "Имя — описание")
                has_names = False
                child_names_str = user_profile.get('child_names', '').strip() if user_profile else ''
                if child_names_str:
                    # Проверяем, содержит ли traits имена из child_names
                    names_list = [name.strip() for name in child_names_str.split(',')]
                    for name in names_list:
                        if name and name in current_traits:
                            has_names = True
                            break
                
                if has_names:
                    traits_instructions = f"""
ВАЖНО для обработки характера (С ИМЕНАМИ ДЕТЕЙ):
Текущий характер: "{current_traits}"

КРИТИЧЕСКИ ВАЖНО: В текущем характере есть имена детей. При обработке ОБЯЗАТЕЛЬНО сохраняй структуру с именами!

При обработке traits учитывай:
1. УДАЛИТЬ ВСЕ: если пользователь говорит "сотри", "удали", "убери" + "характер/черты/все" → traits = "" (пустая строка)
2. УДАЛИТЬ ЧАСТИЧНО: если пользователь говорит "убери [черта]", "удали [черта]" → traits = текущий характер БЕЗ указанной черты, НО С СОХРАНЕНИЕМ ИМЕН И СТРУКТУРЫ
3. ЗАМЕНИТЬ: если пользователь говорит "теперь", "вместо", "замени" → traits = новое значение (полная замена)
4. ДОПОЛНИТЬ: если пользователь говорит "также", "добавь", "еще" или просто описывает новые черты БЕЗ слов замены → traits = текущий характер + новые черты, С СОХРАНЕНИЕМ ВСЕХ ИМЕН И СТРУКТУРЫ
   
   КРИТИЧЕСКИ ВАЖНЫЕ ПРИМЕРЫ ДОПОЛНЕНИЯ:
   - Текущий: "Платон - лидер"
     Запрос: "Платон - стратег"
     Результат: "Платон - лидер, стратег" (НЕ просто "Платон - стратег"!)
   
   - Текущий: "Платон Лидер — умеет вести за собой. Демид Создатель — строит миры."
     Запрос: "Платон также Наставник — любит объяснять. Демид также имеет низкую толерантность к неудаче"
     Результат: "Платон Лидер — умеет вести за собой, Наставник — любит объяснять. Демид Создатель — строит миры, Низкая толерантность к неудаче."
   
   - Текущий: "Платон - лидер"
     Запрос: "Платон - стратег, тактик"
     Результат: "Платон - лидер, стратег, тактик" (сохраняем "лидер" и добавляем новые)
   
   Если пользователь дополняет характер для конкретного ребенка (упоминает имя), добавь черты к этому ребенку. Если не упоминает имя, но в текущем характере есть несколько детей, сохрани структуру для всех детей.

Если traits обновляется, верни финальное значение traits в profile_patch С СОХРАНЕНИЕМ ВСЕХ ИМЕН И СТРУКТУРЫ.
"""
                else:
                    traits_instructions = f"""
ВАЖНО для обработки характера:
Текущий характер: "{current_traits}"

При обработке traits учитывай:
1. УДАЛИТЬ ВСЕ: если пользователь говорит "сотри", "удали", "убери" + "характер/черты/все" → traits = "" (пустая строка)
2. УДАЛИТЬ ЧАСТИЧНО: если пользователь говорит "убери [черта]", "удали [черта]" → traits = текущий характер БЕЗ указанной черты
   Пример: текущий "спокойный, упрямый, добрый", запрос "убери упрямый" → traits = "спокойный, добрый"
3. ЗАМЕНИТЬ: если пользователь говорит "теперь", "вместо", "замени" → traits = новое значение (полная замена)
4. ДОПОЛНИТЬ: если пользователь говорит "также", "добавь", "еще" или просто описывает новые черты → traits = текущий характер + новые черты
   Пример: текущий "спокойный", запрос "также вежливый" → traits = "спокойный, вежливый"

Если traits обновляется, верни финальное значение traits в profile_patch.
"""
            
            # Формируем контекстную заметку для запроса на дополнение характера
            context_note = ""
            if is_add_traits_request:
                # Проверяем, есть ли слова замены в сообщении
                replacement_words = ["замени", "вместо", "теперь", "измени на", "смени на", "удали", "убери", "сотри"]
                has_replacement_word = any(word in user_message.lower() for word in replacement_words)
                
                # Проверяем, упоминает ли пользователь имена, которые уже есть в текущем характере
                mentions_existing_name = False
                if current_traits and child_names_str:
                    names_list = [name.strip() for name in child_names_str.split(',')]
                    for name in names_list:
                        if name and name.lower() in current_traits.lower() and name.lower() in user_message.lower():
                            mentions_existing_name = True
                            break
                
                if not has_replacement_word:
                    if mentions_existing_name:
                        context_note = "\n" + "="*80 + "\n" \
                                      "⚠️ КРИТИЧЕСКИ ВАЖНО: Пользователь нажал кнопку 'Дополнить характер'!\n" \
                                      "Пользователь упоминает имя, которое УЖЕ ЕСТЬ в текущем характере, и НЕ использует слова замены/удаления.\n" \
                                      "Это означает ДОПОЛНЕНИЕ, а не замену!\n\n" \
                                      "ОБЯЗАТЕЛЬНО сохрани текущий характер и добавь к нему новые черты.\n" \
                                      "НЕ заменяй текущий характер полностью!\n\n" \
                                      "ПРАВИЛО: Если текущий характер содержит имя ребенка (например, 'Платон - лидер'), " \
                                      "а пользователь пишет новую черту для того же имени (например, 'Платон - стратег'), " \
                                      "то результат должен быть ОБЪЕДИНЕНИЕМ: 'Платон - лидер, стратег'.\n\n" \
                                      "КОНКРЕТНЫЙ ПРИМЕР:\n" \
                                      "- Текущий характер: 'Платон - лидер'\n" \
                                      "- Запрос пользователя: 'Платон - стратег'\n" \
                                      "- ПРАВИЛЬНЫЙ результат: 'Платон - лидер, стратег'\n" \
                                      "- НЕПРАВИЛЬНЫЙ результат: 'Платон - стратег' (это замена, а не дополнение!)\n\n" \
                                      "="*80 + "\n"
                    else:
                        context_note = "\n⚠️ ВАЖНО: Пользователь нажал кнопку 'Дополнить характер' и НЕ использовал слова замены/удаления.\n" \
                                      "Это означает ДОПОЛНЕНИЕ, а не замену! ОБЯЗАТЕЛЬНО сохрани текущий характер и добавь к нему новые черты.\n\n"
                else:
                    context_note = "\n⚠️ ВАЖНО: Пользователь нажал кнопку 'Дополнить характер', но использовал слова замены/удаления.\n" \
                                  "Обработай запрос согласно указанным словам (замена/удаление), но если это частичное удаление, " \
                                  "сохрани остальные черты характера.\n\n"
            
            user_prompt = f"""Сообщение пользователя: {user_message}
{profile_info}
{context_note}
{traits_instructions}

Верни JSON в следующем формате:
{{
    "should_update_profile": true/false,
    "profile_patch": {{
        "child_names": "string или null",
        "age": "string или null",
        "traits": "string или null (финальное значение после обработки)",
        "last_user_message": "string или null"
    }},
    "deepseek_user_prompt": "полный промпт для генерации сказки на русском языке"
}}"""

            # Вызываем OpenAI
            response = self.client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.7,
                response_format={"type": "json_object"}
            )
            
            # Парсим JSON-ответ
            content = response.choices[0].message.content
            result = json.loads(content)
            
            # Валидация и нормализация
            if "should_update_profile" not in result:
                result["should_update_profile"] = False
            
            if "profile_patch" not in result:
                result["profile_patch"] = {}
            
            if "deepseek_user_prompt" not in result:
                result["deepseek_user_prompt"] = "Напиши сказку ."
            
            # Убираем null значения из profile_patch (пустые строки сохраняются для полного удаления traits)
            profile_patch = {}
            for key in ["child_names", "age", "traits", "last_user_message"]:
                if key in result["profile_patch"] and result["profile_patch"][key] is not None:
                    profile_patch[key] = str(result["profile_patch"][key])
            
            result["profile_patch"] = profile_patch
            
            logger.info(f"Agent 1 обработал сообщение: should_update={result['should_update_profile']}")
            logger.info(f"=== ПРОМПТ ДЛЯ DEEPSEEK (Agent 1) ===\n{result.get('deepseek_user_prompt', 'НЕ СГЕНЕРИРОВАН')}\n{'=' * 50}")
            return result
            
        except json.JSONDecodeError as e:
            logger.error(f"Ошибка парсинга JSON от Agent 1: {e}")
            # Возвращаем дефолтный ответ
            return {
                "should_update_profile": False,
                "profile_patch": {},
                "deepseek_user_prompt": f"Напиши сказку  на основе запроса: {user_message}"
            }
        except Exception as e:
            logger.error(f"Ошибка вызова Agent 1: {e}")
            # Возвращаем дефолтный ответ
            return {
                "should_update_profile": False,
                "profile_patch": {},
                "deepseek_user_prompt": f"Напиши сказку  на основе запроса: {user_message}"
            }
    
    def get_random_moral_by_age(self, age: str) -> str:
        """Получает случайную мораль на основе возраста."""
        # Определяем возрастную группу
        age_str = str(age).strip().lower()
        age_group = None
        
        # Пытаемся извлечь число из возраста
        try:
            age_num = int(''.join(filter(str.isdigit, age_str)))
            if age_num <= 5:
                age_group = "3-5"
            elif age_num <= 8:
                age_group = "6-8"
            elif age_num <= 12:
                age_group = "9-12"
            else:
                age_group = "13+"
        except:
            # Если не удалось определить, используем среднюю группу
            age_group = "6-8"
        
        morals = MORALS_BY_AGE.get(age_group, MORALS_BY_AGE["6-8"])
        
        # Используем secrets.choice для более надежной случайности
        # Это гарантирует, что каждый раз будет выбираться действительно случайная мораль
        selected_moral = secrets.choice(morals)
        
        logger.info(f"Выбрана случайная мораль для возрастной группы {age_group} (возраст: {age}): '{selected_moral}' из {len(morals)} вариантов")
        
        return selected_moral
    
    def process_story_request(
        self,
        request_type: str,
        user_message: str,
        user_profile: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Обрабатывает специальные запросы на генерацию сказки.
        
        request_type может быть:
        - "new_dilemma": новая дилемма (обновляет context_active)
        - "random_moral": случайная мораль (не использует context_active)
        - "previous_moral": прошлая мораль (использует context_active)
        - "add_traits": дополнить характер (обновляет traits)
        - "regular": обычный запрос
        
        Возвращает:
        {
            "request_type": str,
            "deepseek_user_prompt": "string"
        }
        """
        try:
            age = user_profile.get('age', '') if user_profile else ''
            
            if request_type == "new_dilemma":
                # Новая дилемма - формируем промпт на основе новой ситуации
                prompt = f"Напиши сказку, которая разбирает следующую ситуацию: {user_message}. " \
                        f"Сказка, которая помогает ребенку понять, как правильно поступать в такой ситуации."
                logger.info(f"=== ПРОМПТ ДЛЯ DEEPSEEK (new_dilemma) ===\n{prompt}\n{'=' * 50}")
                return {
                    "request_type": "new_dilemma",
                    "deepseek_user_prompt": prompt
                }
            
            elif request_type == "random_moral":
                # Случайная мораль - генерируем мораль на основе возраста
                try:
                    moral = self.get_random_moral_by_age(age)
                    prompt = f"Напиши сказку, которая передает следующую идею (НЕ пиши мораль текстом, она должна быть понятна из действий героя): {moral}. " \
                            f"Сказка должна быть интересной и поучительной, но мораль должна быть скрытой, не проговариваться напрямую."
                    logger.info(f"Сгенерирована случайная мораль для возраста {age}: {moral}")
                    logger.info(f"=== ПРОМПТ ДЛЯ DEEPSEEK (random_moral) ===\n{prompt}\n{'=' * 50}")
                    return {
                        "request_type": "random_moral",
                        "deepseek_user_prompt": prompt,
                        "moral": moral  # Возвращаем мораль для сохранения в context_active
                    }
                except Exception as e:
                    logger.error(f"Ошибка при генерации случайной морали для возраста {age}: {e}", exc_info=True)
                    # Возвращаем дефолтную мораль
                    default_moral = "Дружба важнее игрушек"
                    prompt = f"Напиши сказку, которая передает следующую идею (НЕ пиши мораль текстом, она должна быть понятна из действий героя): {default_moral}. " \
                            f"Сказка должна быть интересной и поучительной, но мораль должна быть скрытой, не проговариваться напрямую."
                    logger.info(f"=== ПРОМПТ ДЛЯ DEEPSEEK (random_moral, fallback) ===\n{prompt}\n{'=' * 50}")
                    return {
                        "request_type": "random_moral",
                        "deepseek_user_prompt": prompt,
                        "moral": default_moral  # Возвращаем мораль для сохранения в context_active
                    }
            
            elif request_type == "previous_moral":
                # Прошлая мораль - используем context_active
                prompt = f"Напиши сказку, которая разбирает следующую ситуацию: {user_message}. " \
                        f"Сказка должна помочь ребенку понять, как правильно поступать в такой ситуации, но НЕ пиши мораль текстом - она должна быть понятна из действий и выбора героя."
                logger.info(f"=== ПРОМПТ ДЛЯ DEEPSEEK (previous_moral) ===\n{prompt}\n{'=' * 50}")
                return {
                    "request_type": "previous_moral",
                    "deepseek_user_prompt": prompt
                }
            
            elif request_type == "add_traits":
                # Дополнить характер - генерируем сказку с учетом того, что пользователь дополнил
                if user_message:
                    prompt = f"Напиши сказку, которая учитывает обновленные черты характера ребенка. " \
                            f"Пользователь дополнил характер следующим: {user_message}. " \
                            f"Сказка должна быть интересной и поучительной, но мораль НЕ должна быть написана текстом - она должна быть понятна из действий и выбора героя."
                else:
                    prompt = "Напиши сказку, которая учитывает обновленные черты характера ребенка. " \
                            f"Сказка должна быть интересной и поучительной, но мораль НЕ должна быть написана текстом - она должна быть понятна из действий и выбора героя."
                logger.info(f"=== ПРОМПТ ДЛЯ DEEPSEEK (add_traits) ===\n{prompt}\n{'=' * 50}")
                return {
                    "request_type": "add_traits",
                    "deepseek_user_prompt": prompt
                }
            
            else:
                # Обычный запрос
                prompt = f"Напиши сказку  на основе запроса: {user_message}"
                logger.info(f"=== ПРОМПТ ДЛЯ DEEPSEEK (regular) ===\n{prompt}\n{'=' * 50}")
                return {
                    "request_type": "regular",
                    "deepseek_user_prompt": prompt
                }
                
        except Exception as e:
            logger.error(f"Ошибка в process_story_request: {e}")
            fallback_prompt = f"Напиши сказку ."
            logger.info(f"=== ПРОМПТ ДЛЯ DEEPSEEK (fallback) ===\n{fallback_prompt}\n{'=' * 50}")
            return {
                "request_type": request_type,
                "deepseek_user_prompt": fallback_prompt
            }

