"""Agent 1 (OpenAI) - роутер логики и генератор промптов для DeepSeek."""
import json
import logging
import random
import secrets
from typing import Dict, Any, Optional, List
from openai import OpenAI

from config import OPENAI_API_KEY

logger = logging.getLogger(__name__)

# Список моралей для разных возрастов
MORALS_BY_AGE = {
    "3-5": [
        "Дружить важнее, чем владеть игрушкой",
        "Делая добро, ты сам становишься счастливее",
        "Делиться — не значит терять",
        "Мама и папа помогают, даже когда запрещают",
        "Добрые слова делают мир мягче",
        "Драться — не способ решать проблемы",
        "Помогать другим — это правильно",
        "Если ошибся, можно попросить прощения",
        "Жадность мешает радоваться",
        "Вежливость открывает сердца",
    ],
    "6-8": [
        "Честность важнее выгоды",
        "Усилие приводит к результату",
        "Не суди других по внешности",
        "Каждый поступок имеет последствия",
        "Настойчивость помогает достигать цели",
        "Ошибки — часть обучения",
        "Хвастовство отталкивает друзей",
        "Быть справедливым важнее чем быть первым",
        "Доброта возвращается",
    ],
    "9-12": [
        "Справедливость важнее личной выгоды",
        "Ответственность — это умение держать слово",
        "Зависть разрушает, труд развивает",
        "Каждый человек ценен, даже если он не похож на тебя",
        "Самоконтроль это сила",
        "Настоящая дружба проверяется поступками",
        "Ошибаться не стыдно, стыдно не учиться",
        "Уважение нужно заслужить делами",
        "Смелость — это делать правильно, даже когда трудно",
    ],
    "13+": [
        "Честность с собой важнее одобрения окружающих",
        "Характер формируется в сложных ситуациях",
        "Популярность не равна уважению",
        "Успех без совести не делает счастливым",
        "Выбор — это всегда отказ от чего-то другого",
        "Сильный человек умеет признавать ошибки",
        "Не каждый конфликт нужно выигрывать",
        "Ценности важнее обстоятельств",
        "Ты отвечаешь не только за свои желания, но и за последствия своих поступков",
    ],
}


class AgentRouter:
    """Agent 1: анализирует сообщения и формирует промпты для DeepSeek."""
    
    def __init__(self):
        self.client = OpenAI(
            api_key=OPENAI_API_KEY,
            base_url="https://api.proxyapi.ru/openai/v1"
        )
    
    def process_message(
        self,
        user_message: str,
        user_profile: Optional[Dict[str, Any]] = None,
        is_add_traits_request: bool = False
    ) -> Dict[str, Any]:
        """
        Обрабатывает сообщение пользователя и возвращает JSON-ответ.
        
        Возвращает:
        {
            "should_update_profile": bool,
            "profile_patch": {
                "child_names": "string_optional",
                "age": "string_optional",
                "traits": "string_optional",
                "last_user_message": "string_optional"
            },
            "deepseek_user_prompt": "string"
        }
        """
        try:
            # Формируем системный промпт для Agent 1
            system_prompt = """Ты — интеллектуальный роутер для бота "Басенник", который помогает родителям наставлять детей через басни.

Твоя задача:
1. Анализировать сообщения пользователя
2. Определять, нужно ли обновлять профиль ребенка (имя, возраст, черты характера)
3. Формировать промпт для генерации басни

ПРАВИЛА:
- Если пользователь корректирует профиль ("ему 6, а не 5", "он не спокойный, а упрямый", "двое детей: Маша и Петя") → should_update_profile=true и заполни profile_patch
- Если запрос просто "напиши басню про..." или обычный запрос басни → should_update_profile=false

ОСОБЫЕ ПРАВИЛА ДЛЯ ОБНОВЛЕНИЯ ХАРАКТЕРА (traits):
- Если пользователь хочет УДАЛИТЬ характер полностью ("сотри прошлый характер", "удали характер", "убери все черты") → traits = "" (пустая строка)
- Если пользователь хочет УДАЛИТЬ частично ("убери упрямство", "удали спокойный", "убери жадность") → traits = финальный список черт БЕЗ указанных для удаления
- Если пользователь хочет ЗАМЕНИТЬ ("теперь он вежливый", "замени на вежливый", "вместо упрямого теперь вежливый") → traits = новое значение (заменяет полностью)
- Если пользователь хочет ДОПОЛНИТЬ ("также вежливый", "добавь вежливый", "еще он вежливый") → traits = текущий характер + новые черты
- Если в сообщении есть слова "сотри", "удали", "убери", "замени", "вместо" → это указание на удаление/замену, а не дополнение
- ВАЖНО: Если пользователь просто описывает новые черты характера БЕЗ явных слов удаления/замены (например, "Платон Лидер — умеет вести за собой, Наставник — любит объяснять"), это считается ДОПОЛНЕНИЕМ, а не заменой. Сохраняй текущий характер и добавляй новые черты.
- КРИТИЧЕСКИ ВАЖНО: Если в текущем характере есть имена детей (например, "Платон Лидер — ... Демид Создатель — ..."), при дополнении ОБЯЗАТЕЛЬНО сохраняй структуру с именами. Не смешивай черты разных детей в один список.

- deepseek_user_prompt: на русском языке, не в стихах, 500-800 слов (ОБЯЗАТЕЛЬНО соблюдай эту длину), учитывай профиль ребенка(детей) + запрос пользователя. 
- Не проси писать про возраст детей текстом, но ОБЯЗАТЕЛЬНО проси учитывать возраст при написании басни: в зависимости от возраста регулируй сложность контекста, литературных выражений и морали.
- Не проси писать черты характера текстом, но ОБЯЗАТЕЛЬНО проси отразить их в поведении и поступках героя.
- НИКОГДА не проси писать мораль текстом в конце или в середине басни. Мораль должна быть скрытой, понятной только из действий героя.
- НЕ используй мат и контент 18+

ВАЖНО: Возвращай ТОЛЬКО валидный JSON без пояснений и комментариев."""

            # Формируем промпт пользователя
            profile_info = ""
            current_traits = ""
            if user_profile:
                current_traits = user_profile.get('traits', '').strip()
                profile_info = f"""
Профиль ребенка:
- Имя: {user_profile.get('child_names', 'не указано')}
- Возраст: {user_profile.get('age', 'не указан')}
- Текущие черты характера: {current_traits if current_traits else 'не указаны'}
"""
            
            traits_instructions = ""
            if current_traits:
                # Проверяем, есть ли в traits имена детей (начинается с имени или содержит структуру "Имя — описание")
                has_names = False
                child_names_str = user_profile.get('child_names', '').strip() if user_profile else ''
                if child_names_str:
                    # Проверяем, содержит ли traits имена из child_names
                    names_list = [name.strip() for name in child_names_str.split(',')]
                    for name in names_list:
                        if name and name in current_traits:
                            has_names = True
                            break
                
                if has_names:
                    traits_instructions = f"""
ВАЖНО для обработки характера (С ИМЕНАМИ ДЕТЕЙ):
Текущий характер: "{current_traits}"

КРИТИЧЕСКИ ВАЖНО: В текущем характере есть имена детей. При обработке ОБЯЗАТЕЛЬНО сохраняй структуру с именами!

При обработке traits учитывай:
1. УДАЛИТЬ ВСЕ: если пользователь говорит "сотри", "удали", "убери" + "характер/черты/все" → traits = "" (пустая строка)
2. УДАЛИТЬ ЧАСТИЧНО: если пользователь говорит "убери [черта]", "удали [черта]" → traits = текущий характер БЕЗ указанной черты, НО С СОХРАНЕНИЕМ ИМЕН И СТРУКТУРЫ
3. ЗАМЕНИТЬ: если пользователь говорит "теперь", "вместо", "замени" → traits = новое значение (полная замена)
4. ДОПОЛНИТЬ: если пользователь говорит "также", "добавь", "еще" или просто описывает новые черты БЕЗ слов замены → traits = текущий характер + новые черты, С СОХРАНЕНИЕМ ВСЕХ ИМЕН И СТРУКТУРЫ
   
   КРИТИЧЕСКИ ВАЖНЫЕ ПРИМЕРЫ ДОПОЛНЕНИЯ:
   - Текущий: "Платон - лидер"
     Запрос: "Платон - стратег"
     Результат: "Платон - лидер, стратег" (НЕ просто "Платон - стратег"!)
   
   - Текущий: "Платон Лидер — умеет вести за собой. Демид Создатель — строит миры."
     Запрос: "Платон также Наставник — любит объяснять. Демид также имеет низкую толерантность к неудаче"
     Результат: "Платон Лидер — умеет вести за собой, Наставник — любит объяснять. Демид Создатель — строит миры, Низкая толерантность к неудаче."
   
   - Текущий: "Платон - лидер"
     Запрос: "Платон - стратег, тактик"
     Результат: "Платон - лидер, стратег, тактик" (сохраняем "лидер" и добавляем новые)
   
   Если пользователь дополняет характер для конкретного ребенка (упоминает имя), добавь черты к этому ребенку. Если не упоминает имя, но в текущем характере есть несколько детей, сохрани структуру для всех детей.

Если traits обновляется, верни финальное значение traits в profile_patch С СОХРАНЕНИЕМ ВСЕХ ИМЕН И СТРУКТУРЫ.
"""
                else:
                    traits_instructions = f"""
ВАЖНО для обработки характера:
Текущий характер: "{current_traits}"

При обработке traits учитывай:
1. УДАЛИТЬ ВСЕ: если пользователь говорит "сотри", "удали", "убери" + "характер/черты/все" → traits = "" (пустая строка)
2. УДАЛИТЬ ЧАСТИЧНО: если пользователь говорит "убери [черта]", "удали [черта]" → traits = текущий характер БЕЗ указанной черты
   Пример: текущий "спокойный, упрямый, добрый", запрос "убери упрямый" → traits = "спокойный, добрый"
3. ЗАМЕНИТЬ: если пользователь говорит "теперь", "вместо", "замени" → traits = новое значение (полная замена)
4. ДОПОЛНИТЬ: если пользователь говорит "также", "добавь", "еще" или просто описывает новые черты → traits = текущий характер + новые черты
   Пример: текущий "спокойный", запрос "также вежливый" → traits = "спокойный, вежливый"

Если traits обновляется, верни финальное значение traits в profile_patch.
"""
            
            # Формируем контекстную заметку для запроса на дополнение характера
            context_note = ""
            if is_add_traits_request:
                # Проверяем, есть ли слова замены в сообщении
                replacement_words = ["замени", "вместо", "теперь", "измени на", "смени на", "удали", "убери", "сотри"]
                has_replacement_word = any(word in user_message.lower() for word in replacement_words)
                
                # Проверяем, упоминает ли пользователь имена, которые уже есть в текущем характере
                mentions_existing_name = False
                if current_traits and child_names_str:
                    names_list = [name.strip() for name in child_names_str.split(',')]
                    for name in names_list:
                        if name and name.lower() in current_traits.lower() and name.lower() in user_message.lower():
                            mentions_existing_name = True
                            break
                
                if not has_replacement_word:
                    if mentions_existing_name:
                        context_note = "\n" + "="*80 + "\n" \
                                      "⚠️ КРИТИЧЕСКИ ВАЖНО: Пользователь нажал кнопку 'Дополнить характер'!\n" \
                                      "Пользователь упоминает имя, которое УЖЕ ЕСТЬ в текущем характере, и НЕ использует слова замены/удаления.\n" \
                                      "Это означает ДОПОЛНЕНИЕ, а не замену!\n\n" \
                                      "ОБЯЗАТЕЛЬНО сохрани текущий характер и добавь к нему новые черты.\n" \
                                      "НЕ заменяй текущий характер полностью!\n\n" \
                                      "ПРАВИЛО: Если текущий характер содержит имя ребенка (например, 'Платон - лидер'), " \
                                      "а пользователь пишет новую черту для того же имени (например, 'Платон - стратег'), " \
                                      "то результат должен быть ОБЪЕДИНЕНИЕМ: 'Платон - лидер, стратег'.\n\n" \
                                      "КОНКРЕТНЫЙ ПРИМЕР:\n" \
                                      "- Текущий характер: 'Платон - лидер'\n" \
                                      "- Запрос пользователя: 'Платон - стратег'\n" \
                                      "- ПРАВИЛЬНЫЙ результат: 'Платон - лидер, стратег'\n" \
                                      "- НЕПРАВИЛЬНЫЙ результат: 'Платон - стратег' (это замена, а не дополнение!)\n\n" \
                                      "="*80 + "\n"
                    else:
                        context_note = "\n⚠️ ВАЖНО: Пользователь нажал кнопку 'Дополнить характер' и НЕ использовал слова замены/удаления.\n" \
                                      "Это означает ДОПОЛНЕНИЕ, а не замену! ОБЯЗАТЕЛЬНО сохрани текущий характер и добавь к нему новые черты.\n\n"
                else:
                    context_note = "\n⚠️ ВАЖНО: Пользователь нажал кнопку 'Дополнить характер', но использовал слова замены/удаления.\n" \
                                  "Обработай запрос согласно указанным словам (замена/удаление), но если это частичное удаление, " \
                                  "сохрани остальные черты характера.\n\n"
            
            user_prompt = f"""Сообщение пользователя: {user_message}
{profile_info}
{context_note}
{traits_instructions}

Верни JSON в следующем формате:
{{
    "should_update_profile": true/false,
    "profile_patch": {{
        "child_names": "string или null",
        "age": "string или null",
        "traits": "string или null (финальное значение после обработки)",
        "last_user_message": "string или null"
    }},
    "deepseek_user_prompt": "полный промпт для генерации басни на русском языке"
}}"""

            # Вызываем OpenAI
            response = self.client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.7,
                response_format={"type": "json_object"}
            )
            
            # Парсим JSON-ответ
            content = response.choices[0].message.content
            result = json.loads(content)
            
            # Валидация и нормализация
            if "should_update_profile" not in result:
                result["should_update_profile"] = False
            
            if "profile_patch" not in result:
                result["profile_patch"] = {}
            
            if "deepseek_user_prompt" not in result:
                result["deepseek_user_prompt"] = "Напиши басню ."
            
            # Убираем null значения из profile_patch (пустые строки сохраняются для полного удаления traits)
            profile_patch = {}
            for key in ["child_names", "age", "traits", "last_user_message"]:
                if key in result["profile_patch"] and result["profile_patch"][key] is not None:
                    profile_patch[key] = str(result["profile_patch"][key])
            
            result["profile_patch"] = profile_patch
            
            logger.info(f"Agent 1 обработал сообщение: should_update={result['should_update_profile']}")
            logger.info(f"=== ПРОМПТ ДЛЯ DEEPSEEK (Agent 1) ===\n{result.get('deepseek_user_prompt', 'НЕ СГЕНЕРИРОВАН')}\n{'=' * 50}")
            return result
            
        except json.JSONDecodeError as e:
            logger.error(f"Ошибка парсинга JSON от Agent 1: {e}")
            # Возвращаем дефолтный ответ
            return {
                "should_update_profile": False,
                "profile_patch": {},
                "deepseek_user_prompt": f"Напиши басню  на основе запроса: {user_message}"
            }
        except Exception as e:
            logger.error(f"Ошибка вызова Agent 1: {e}")
            # Возвращаем дефолтный ответ
            return {
                "should_update_profile": False,
                "profile_patch": {},
                "deepseek_user_prompt": f"Напиши басню  на основе запроса: {user_message}"
            }
    
    def get_random_moral_by_age(self, age: str) -> str:
        """Получает случайную мораль на основе возраста."""
        # Определяем возрастную группу
        age_str = str(age).strip().lower()
        age_group = None
        
        # Пытаемся извлечь число из возраста
        try:
            age_num = int(''.join(filter(str.isdigit, age_str)))
            if age_num <= 5:
                age_group = "3-5"
            elif age_num <= 8:
                age_group = "6-8"
            elif age_num <= 12:
                age_group = "9-12"
            else:
                age_group = "13+"
        except:
            # Если не удалось определить, используем среднюю группу
            age_group = "6-8"
        
        morals = MORALS_BY_AGE.get(age_group, MORALS_BY_AGE["6-8"])
        
        # Используем secrets.choice для более надежной случайности
        # Это гарантирует, что каждый раз будет выбираться действительно случайная мораль
        selected_moral = secrets.choice(morals)
        
        logger.info(f"Выбрана случайная мораль для возрастной группы {age_group} (возраст: {age}): '{selected_moral}' из {len(morals)} вариантов")
        
        return selected_moral
    
    def process_story_request(
        self,
        request_type: str,
        user_message: str,
        user_profile: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Обрабатывает специальные запросы на генерацию басни.
        
        request_type может быть:
        - "new_dilemma": новая дилемма (обновляет context_active)
        - "random_moral": случайная мораль (не использует context_active)
        - "previous_moral": прошлая мораль (использует context_active)
        - "add_traits": дополнить характер (обновляет traits)
        - "regular": обычный запрос басни
        
        Возвращает:
        {
            "request_type": str,
            "deepseek_user_prompt": "string"
        }
        """
        try:
            age = user_profile.get('age', '') if user_profile else ''
            
            if request_type == "new_dilemma":
                # Новая дилемма - формируем промпт на основе новой ситуации
                prompt = f"Напиши басню, которая разбирает следующую ситуацию: {user_message}. " \
                        f"Басня, которая помогает ребенку понять, как правильно поступать в такой ситуации."
                logger.info(f"=== ПРОМПТ ДЛЯ DEEPSEEK (new_dilemma) ===\n{prompt}\n{'=' * 50}")
                return {
                    "request_type": "new_dilemma",
                    "deepseek_user_prompt": prompt
                }
            
            elif request_type == "random_moral":
                # Случайная мораль - генерируем мораль на основе возраста
                try:
                    moral = self.get_random_moral_by_age(age)
                    prompt = f"Напиши басню, которая передает следующую идею (НЕ пиши мораль текстом, она должна быть понятна из действий героя): {moral}. " \
                            f"Басня должна быть интересной и поучительной, но мораль должна быть скрытой, не проговариваться напрямую."
                    logger.info(f"Сгенерирована случайная мораль для возраста {age}: {moral}")
                    logger.info(f"=== ПРОМПТ ДЛЯ DEEPSEEK (random_moral) ===\n{prompt}\n{'=' * 50}")
                    return {
                        "request_type": "random_moral",
                        "deepseek_user_prompt": prompt,
                        "moral": moral  # Возвращаем мораль для сохранения в context_active
                    }
                except Exception as e:
                    logger.error(f"Ошибка при генерации случайной морали для возраста {age}: {e}", exc_info=True)
                    # Возвращаем дефолтную мораль
                    default_moral = "Дружба важнее игрушек"
                    prompt = f"Напиши басню, которая передает следующую идею (НЕ пиши мораль текстом, она должна быть понятна из действий героя): {default_moral}. " \
                            f"Басня должна быть интересной и поучительной, но мораль должна быть скрытой, не проговариваться напрямую."
                    logger.info(f"=== ПРОМПТ ДЛЯ DEEPSEEK (random_moral, fallback) ===\n{prompt}\n{'=' * 50}")
                    return {
                        "request_type": "random_moral",
                        "deepseek_user_prompt": prompt,
                        "moral": default_moral  # Возвращаем мораль для сохранения в context_active
                    }
            
            elif request_type == "previous_moral":
                # Прошлая мораль - используем context_active
                prompt = f"Напиши басню, которая разбирает следующую ситуацию: {user_message}. " \
                        f"Басня должна помочь ребенку понять, как правильно поступать в такой ситуации, но НЕ пиши мораль текстом - она должна быть понятна из действий и выбора героя."
                logger.info(f"=== ПРОМПТ ДЛЯ DEEPSEEK (previous_moral) ===\n{prompt}\n{'=' * 50}")
                return {
                    "request_type": "previous_moral",
                    "deepseek_user_prompt": prompt
                }
            
            elif request_type == "add_traits":
                # Дополнить характер - генерируем басню с учетом того, что пользователь дополнил
                if user_message:
                    prompt = f"Напиши басню, которая учитывает обновленные черты характера ребенка. " \
                            f"Пользователь дополнил характер следующим: {user_message}. " \
                            f"Басня должна быть интересной и поучительной, но мораль НЕ должна быть написана текстом - она должна быть понятна из действий и выбора героя."
                else:
                    prompt = "Напиши басню, которая учитывает обновленные черты характера ребенка. " \
                            f"Басня должна быть интересной и поучительной, но мораль НЕ должна быть написана текстом - она должна быть понятна из действий и выбора героя."
                logger.info(f"=== ПРОМПТ ДЛЯ DEEPSEEK (add_traits) ===\n{prompt}\n{'=' * 50}")
                return {
                    "request_type": "add_traits",
                    "deepseek_user_prompt": prompt
                }
            
            elif request_type == "wishes":
                # Пожелания - генерируем басню с учетом пожеланий пользователя
                prompt = f"Напиши басню с учетом следующих пожеланий пользователя: {user_message}. " \
                        f"Басня должна быть интересной и поучительной, но мораль НЕ должна быть написана текстом - она должна быть понятна из действий и выбора героя."
                logger.info(f"=== ПРОМПТ ДЛЯ DEEPSEEK (wishes) ===\n{prompt}\n{'=' * 50}")
                return {
                    "request_type": "wishes",
                    "deepseek_user_prompt": prompt
                }
            
            else:
                # Обычный запрос
                prompt = f"Напиши басню  на основе запроса: {user_message}"
                logger.info(f"=== ПРОМПТ ДЛЯ DEEPSEEK (regular) ===\n{prompt}\n{'=' * 50}")
                return {
                    "request_type": "regular",
                    "deepseek_user_prompt": prompt
                }
                
        except Exception as e:
            logger.error(f"Ошибка в process_story_request: {e}")
            fallback_prompt = f"Напиши басню ."
            logger.info(f"=== ПРОМПТ ДЛЯ DEEPSEEK (fallback) ===\n{fallback_prompt}\n{'=' * 50}")
            return {
                "request_type": request_type,
                "deepseek_user_prompt": fallback_prompt
            }
    
    def generate_reflection_questions(
        self,
        story_text: str,
        user_profile: Optional[Dict[str, Any]] = None
    ) -> List[str]:
        """
        Генерирует 3 вопроса для размышлений на основе последней сказки.
        
        Args:
            story_text: Текст последней сказки
            user_profile: Профиль пользователя (для учета возраста)
        
        Returns:
            Список из 3 вопросов для размышлений
        """
        try:
            # Определяем возрастную группу
            age = user_profile.get('age', '') if user_profile else ''
            age_group = self._get_age_group(age)
            
            # Формируем системный промпт с учетом возраста
            age_instructions = self._get_age_specific_instructions(age_group)
            
            system_prompt = f"""Ты — помощник для бота "Баснописец", который помогает родителям развивать рефлексию у детей через вопросы после прочтения басни.

Твоя задача:
Сгенерировать 3 вопроса для размышлений на основе прочитанной басни.

{age_instructions}

Формат ответа: JSON с массивом из 3 вопросов:
{{
    "questions": [
        "Вопрос 1",
        "Вопрос 2", 
        "Вопрос 3"
    ]
}}

ВАЖНО: Возвращай ТОЛЬКО валидный JSON без пояснений и комментариев."""

            # Формируем промпт пользователя
            age_info = f"\nВозраст ребенка: {age} (возрастная группа: {age_group})" if age else "\nВозраст не указан, используй среднюю сложность."
            
            user_prompt = f"""Прочитай следующую басню и сгенерируй 3 вопроса для размышлений.{age_info}

БАСНЯ:
{story_text}

Сгенерируй 3 вопроса, которые помогут ребенку:
- Понять мораль басни
- Задуматься о своих поступках
- Применить уроки басни к своей жизни
- Обсудить с родителями важные темы

Верни JSON в формате:
{{
    "questions": [
        "Вопрос 1",
        "Вопрос 2",
        "Вопрос 3"
    ]
}}"""

            # Вызываем OpenAI
            response = self.client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.7,
                response_format={"type": "json_object"}
            )
            
            # Парсим JSON-ответ
            content = response.choices[0].message.content
            result = json.loads(content)
            
            # Извлекаем вопросы
            questions = result.get("questions", [])
            
            # Валидация: должно быть 3 вопроса
            if not questions or len(questions) != 3:
                logger.warning(f"Получено {len(questions)} вопросов вместо 3, генерирую дефолтные")
                questions = self._get_default_questions(age_group)
            
            # Ограничиваем длину каждого вопроса
            questions = [q[:200] for q in questions if q]
            
            logger.info(f"Сгенерировано {len(questions)} вопросов для размышлений (возрастная группа: {age_group})")
            return questions
            
        except json.JSONDecodeError as e:
            logger.error(f"Ошибка парсинга JSON при генерации вопросов: {e}")
            age_group = self._get_age_group(user_profile.get('age', '') if user_profile else '')
            return self._get_default_questions(age_group)
        except Exception as e:
            logger.error(f"Ошибка при генерации вопросов для размышлений: {e}", exc_info=True)
            age_group = self._get_age_group(user_profile.get('age', '') if user_profile else '')
            return self._get_default_questions(age_group)
    
    def _get_age_group(self, age: str) -> str:
        """Определяет возрастную группу на основе возраста."""
        age_str = str(age).strip().lower()
        
        try:
            age_num = int(''.join(filter(str.isdigit, age_str)))
            if age_num <= 5:
                return "3-5"
            elif age_num <= 8:
                return "6-8"
            elif age_num <= 12:
                return "9-12"
            else:
                return "13+"
        except:
            return "6-8"  # Дефолтная группа
    
    def _get_age_specific_instructions(self, age_group: str) -> str:
        """Возвращает инструкции для генерации вопросов в зависимости от возрастной группы."""
        if age_group == "3-5":
            return """Вопросы должны быть:
1. ОЧЕНЬ ПРОСТЫМИ - используй короткие предложения (5-7 слов максимум)
2. КОНКРЕТНЫМИ - про конкретных героев и их действия (Что сделал зайчик?, Почему мишка грустил?)
3. ЭМОЦИОНАЛЬНЫМИ - про чувства (Как ты думаешь, что почувствовал...?, Тебе было бы грустно, если...?)
4. БЕЗ АБСТРАКТНЫХ ПОНЯТИЙ - избегай слов мораль, урок, ценность, принцип
5. С ПРИМЕРАМИ ИЗ ЖИЗНИ - А ты делишься игрушками?, Ты тоже так делаешь?

Примеры хороших вопросов для 3-5 лет:
- Что сделал зайчик, когда увидел грустного мишку?
- А ты делишься игрушками с друзьями?
- Почему зайчик стал счастливым в конце?"""
        
        elif age_group == "6-8":
            return """Вопросы должны быть:
1. ПРОСТЫМИ - короткие предложения (8-12 слов)
2. ПРО ПОСТУПКИ - Что сделал герой?, Правильно ли он поступил?
3. ПРО ВЫБОР - Как бы ты поступил?, Что бы ты выбрал?
4. ПРО ПОСЛЕДСТВИЯ - Что случилось, когда герой...?, Что из-за этого произошло?
5. СВЯЗАННЫМИ С ЖИЗНЬЮ - А в твоей жизни бывает так?, Ты когда-нибудь так делал?

Примеры хороших вопросов для 6-8 лет:
- Правильно ли поступил герой? Почему?
- Как бы ты поступил на месте героя?
- Что случилось, когда герой не поделился?"""
        
        elif age_group == "9-12":
            return """Вопросы должны быть:
1. СРЕДНЕЙ СЛОЖНОСТИ - предложения 10-15 слов
2. ПРО МОРАЛЬ И ЦЕННОСТИ - Чему учит эта басня?, Какая главная мысль?
3. ПРО РЕФЛЕКСИЮ - Как это относится к твоей жизни?, Когда ты поступал похоже?
4. ПРО ВЫБОРЫ И ОТВЕТСТВЕННОСТЬ - Почему важно делать правильный выбор?, За что отвечает герой?
5. С АНАЛИЗОМ - Почему герой так поступил?, Что бы изменилось, если бы он поступил иначе?

Примеры хороших вопросов для 9-12 лет:
- Чему учит нас эта басня? Как это можно применить в жизни?
- Почему герой сделал такой выбор? Согласен ли ты с ним?
- Как бы ты поступил в похожей ситуации? Почему?"""
        
        elif age_group == "13+":
            return """Вопросы должны быть:
1. БОЛЕЕ СЛОЖНЫМИ - предложения 12-20 слов
2. ПРО ЦЕННОСТИ И ПРИНЦИПЫ - Какие ценности важны в этой ситуации?, Какой принцип здесь нарушен?
3. ПРО РЕФЛЕКСИЮ И САМОПОЗНАНИЕ - Как это связано с твоими ценностями?, Что это говорит о характере героя?
4. ПРО ЭТИКУ И МОРАЛЬ - Правильно ли это с этической точки зрения?, Где граница между правильным и неправильным?
5. С ФИЛОСОФСКИМ ПОДТЕКСТОМ - Что важнее: быть правым или быть добрым?, Всегда ли цель оправдывает средства?

Примеры хороших вопросов для 13+ лет:
- Какие моральные принципы нарушил герой? Согласен ли ты с его выбором?
- Как эта ситуация отражает реальные жизненные дилеммы? Приведи примеры.
- Что важнее в этой ситуации: личная выгода или справедливость? Почему?"""
        
        else:
            # Дефолт для 6-8
            return """Вопросы должны быть:
1. ПРОСТЫМИ - короткие предложения (8-12 слов)
2. ПРО ПОСТУПКИ - Что сделал герой?, Правильно ли он поступил?
3. ПРО ВЫБОР - Как бы ты поступил?, Что бы ты выбрал?
4. ПРО ПОСЛЕДСТВИЯ - Что случилось, когда герой...?, Что из-за этого произошло?
5. СВЯЗАННЫМИ С ЖИЗНЬЮ - А в твоей жизни бывает так?, Ты когда-нибудь так делал?

Примеры хороших вопросов для 6-8 лет:
- Правильно ли поступил герой? Почему?
- Как бы ты поступил на месте героя?
- Что случилось, когда герой не поделился?"""
    
    def _get_default_questions(self, age_group: str) -> List[str]:
        """Возвращает дефолтные вопросы в зависимости от возрастной группы."""
        defaults = {
            "3-5": [
                "Что сделал главный герой?",
                "А ты так делаешь?",
                "Почему герой стал счастливым?"
            ],
            "6-8": [
                "Что главный герой сделал правильно, а что нет?",
                "Как бы ты поступил на месте героя?",
                "Чему нас учит эта басня?"
            ],
            "9-12": [
                "Чему учит нас эта басня? Как это можно применить в жизни?",
                "Почему герой сделал такой выбор? Согласен ли ты с ним?",
                "Как бы ты поступил в похожей ситуации? Почему?"
            ],
            "13+": [
                "Какие моральные принципы отражены в этой басне?",
                "Как эта ситуация связана с реальными жизненными дилеммами?",
                "Что важнее в этой ситуации: личная выгода или справедливость?"
            ]
        }
        return defaults.get(age_group, defaults["6-8"])

